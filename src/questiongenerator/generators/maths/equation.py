import sympy
import random

from ..utils import get_random_number, range_list
from ..abstractgenerator import AbstractGenerator
from ...base import NumericalQuestion

class LinearEquation(AbstractGenerator):
    """ Generator for linear equations.

    Args:
        type (str): Type of equation. Posible values 'simple', 'parentesis', 'fraction' and 'random'.
        max_coef: The terms coeficients will be between -max_coef and +maxcoef.
        max_sol: The equation solution will be between -max_sol and max_sol.
        num_left_terms: Number of terms of the left member.
        num_right_terms: Number of terms of the right member.
        labels: Labels that should be used in the question. Must containe the keys "question-text", "question-name", "feedback-right" and "feedback-wrong". Question text value must have a format placeholder called "equation" and feeedback-wrong must have a format placeholder called solution.
    """

    __LABELS_DEFAULT = {
        "question-text":  "Solve next linear equation: {equation}",
        "question-name":  "Linear equation {}",
        "feedback-right": "Great!",
        "feedback-wrong": "Check this equation. Its solution is {solution}."
    }

    def __init__(self, type='simple', max_coef=10, max_sol=10, num_left_terms=0, num_right_terms=0, labels=__LABELS_DEFAULT):
        super(LinearEquation, self)

        if (type not in ['random', 'parentesis', 'fraction', 'simple']):
            raise ValueError("{} type value is not implemented".format(type))

        if max_coef <= 0 or max_sol <= 0 or num_left_terms < 0 or num_right_terms < 0:
            raise ValueError("Parameters max_coef, max_sol, num_left_terms and num_right_terms must be positive values.")

        missing_labels = [k for k in self.__LABELS_DEFAULT.keys() if k not in labels]
        if missing_labels:
            raise ValueError("Labels {} are missing.".format(missing_labels))

        self.maxcoef = max_coef
        self.maxsol = max_sol
        self.lterms = num_left_terms
        self.rterms = num_right_terms
        self.type = type
        self.labels = labels

    def __get_simple_term(self, var):
        """ Generates a random simple term with the form a*var where a is a random number.

            Args:
                var: Variable to use in the term.

            Returns:
                A sympy expression with the form "a * var".
        """
        coeficient = get_random_number(range_list(1, self.maxcoef))
        return coeficient * var

    def __get_parentesis_term(self, var):
        """ Generates a random term with the form "a * (b * var + c)" where a, b and c are random numbers.

            Args:
                var: Variable to use in the term.

            Returns:
                A sympy expression with the form "a * (b * var + c)".
        """
        a = get_random_number(range_list(2, self.maxcoef))
        b = get_random_number(self.maxcoef, [0,])
        c = get_random_number(self.maxcoef, [0,])
        return sympy.Mul(a, b * var + c, evaluate=False)

    def __get_fraction_term(self, var):
        """ Generates a random term with the form "t/d" where t is a random parentesis term generated by __get_parentesis_term and d is a random number.

            Args:
                var: Variable to use in the term.

            Returns:
                A SymPy expression with the form "t/d".
        """
        num = self.__get_parentesis_term(var)
        den = get_random_number(range_list(1, self.maxcoef))
        with sympy.evaluate(False):
            return (num)/(den)

    def __get_term(self, var, type='simple'):
        """ Generates a term of the specified type.

            Args:
                var: Variable to use in the term.
                type: Type of the term. Could be 'random', 'parentesis', 'fraction' y 'simple'.

            Returns:
                A tuple formed by a term and boolean which is True if the term is positive and false if it is negative.
        """
        assert type in ['random', 'parentesis', 'fraction', 'simple']

        if type == 'random':
            type = random.choice(['parentesis', 'fraction', 'simple'])

        if (type == 'parentesis'):
            term = self.__get_parentesis_term(var)
        elif (type == 'fraction'):
            term = self.__get_fraction_term(var)
        elif random.randint(0, 4): #Simple terms generates a simple term or an independent term.
            term = self.__get_simple_term(var)
        else:
            term = get_random_number(range_list(1, self.maxcoef))

        return (term, random.getrandbits(1))

    def __get_expression(self, term_list):
        """ Generates a sympy expression from a list of terms.

            Args:
                term_list: List of terms. Must not be empty. Each term is a tuple with a SymPy expression and a boolean. Boolean value is True if the term is positive and False if it's negative.

            Returns:
                A SymPy expression.
        """
        assert(term_list)

        terms = list(term_list)

        term, sign = terms.pop(0)
        exp = + term if sign else - term

        while (terms):
            term, sign = terms.pop(0)
            exp = exp + term if sign else exp - term
        return exp

    def __get_latex(self, term_list):
        """ Generates a LaTeX string from an expression.

            Args:
                term_list: List of terms. Must not be empty. Each term is a tuple with a SymPy expression and a boolean. Boolean value is True if the term is positive and False if it's negative.

            Returns:
                str: an string with the LaTex representation of that term_list.
        """
        assert(term_list)

        terms = list(term_list)

        term, sign = terms.pop(0)
        ret = "" if sign else "-"
        ret += sympy.latex(term)

        while terms:
            term, sign = terms.pop(0)
            ret += " + " if sign else " - "
            ret += sympy.latex(term)

        return ret

    def __get_equation(self):
        """Generates a linear equation.

            Returns:
                dict: A dictionary formed by "right-member", "left-member" and "solution" keys. The member are a tuple formed by a list of terms and a list of signs.
        """
        x, y = sympy.symbols('x y')

        while True:
            # The intuitive way would be to sum all terms together but if we do so SymPy is going to
            # actually sum them. On the other way if we use evaluate(False) and sum the terms Sympy
            # is going to add some parentesis that we don't want. Se we keep a list of terms and a # list of signs and when we need it we transform it in a actual SymPy expression.

            #The left member has the term we generate.
            left_member = [(x, True),]

            for _ in range(self.lterms):
                left_member.append(self.__get_term(x, self.type))

            #The right member is the variable y with positive sign.
            right_member = [(y, True),]

            for _ in range(self.rterms):
                right_member.append(self.__get_term(x, self.type))

            #We choose a random solution for x variable and calculate the value for y variable.
            xsolution = get_random_number(self.maxsol)
            rm_exp = self.__get_expression(right_member)
            lm_exp = self.__get_expression(left_member)
            eq = sympy.Eq(rm_exp, lm_exp)
            eq = eq.subs(x, xsolution)
            soly = sympy.solve(eq)[0]
            right_member[0] = (abs(soly), soly >= 0)

            #Check if generated equation is a identity.
            rm_exp = self.__get_expression(right_member)
            lm_exp = self.__get_expression(left_member)
            eq = sympy.Eq(rm_exp, lm_exp)
            try:
                bool(eq) #Identities can be casted to Boolean
                continue
            except TypeError:
                break

            #Check if the y value for the generated equation is too big (more than 3 times maxcoef)
            if abs(soly) < self.maxcoef * 3:
                break

        return {
            "right-member": right_member,
            "left-member": left_member,
            "solution": xsolution
        }


    def get_question(self):
        """ Generates a question.

            Returns:
                A NumericalQuestion instance.
        """

        eq = self.__get_equation()

        equation = self.__get_latex(eq["left-member"]) + \
                   " = " + \
                   self.__get_latex(eq["right-member"])

        args = {
            "equation": ('tex', equation)
        }

        answers = [
            {
                "value": eq["solution"],
                "correct": True,
                "feedback": self.labels["feedback-right"]
            },
            {
                "value": "*",
                "correct": False,
                "feedback":self.labels["feedback-wrong"].format(solution=eq["solution"])
            }
        ]

        return NumericalQuestion(self.labels["question-name"], self.labels["question-text"], args, answers)
